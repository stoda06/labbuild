{% extends 'base.html' %}

{% block title %}LabBuild Pseudo-Terminal{% endblock %}

{% block content %}
<h1 class="mb-3">LabBuild Command Executor</h1>

<div class="card">
  <div class="card-header">Enter Command</div>
  <div class="card-body">
    <form id="commandForm" action="javascript:void(0);"> {# Prevent default form submission #}
      <div class="input-group mb-3">
          <span class="input-group-text" id="prompt">labbuild></span>
          <input type="text" class="form-control" id="commandInput" name="command" placeholder="e.g., setup -v cp -g CCSA-R81.20 --host hydra -s 1 -e 1" aria-label="Command Input" aria-describedby="prompt" required autocomplete="off">
          <button class="btn btn-primary" type="submit" id="submitBtn">Execute</button>
      </div>
      <small class="form-text text-muted">Enter your full `labbuild` command (e.g., `setup -v ...`, `teardown -v ...`, `-l -v ...`).</small>
    </form>
  </div>
</div>

<div class="card mt-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <span>Output</span>
        <button class="btn btn-sm btn-outline-secondary" id="clearOutputBtn">Clear</button>
    </div>
    <div class="card-body">
        {# Use <pre> for preformatted text #}
        <pre id="output" style="white-space: pre-wrap; word-wrap: break-word; background-color: #f8f9fa; border: 1px solid #dee2e6; min-height: 300px; max-height: 600px; overflow-y: auto; padding: 10px; border-radius: 4px; font-family: monospace;"></pre>
        {# Add dark mode style override if needed #}
        <style> body.dark-mode #output { background-color: #212529; border-color: #495057; color: #e9ecef; } </style>
    </div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }} {# Include base scripts like dark mode and timezone #}
<script>
    const form = document.getElementById('commandForm');
    const input = document.getElementById('commandInput');
    const output = document.getElementById('output');
    const submitBtn = document.getElementById('submitBtn');
    const clearBtn = document.getElementById('clearOutputBtn');
    let eventSource = null; // Variable to hold the EventSource object

    function appendOutput(message, isError = false) {
        const line = document.createElement('div');
        // Basic sanitation: replace potential HTML tags (not foolproof security)
        line.textContent = message;
        if (isError) {
            line.style.color = 'red';
            line.style.fontWeight = 'bold';
        }
        output.appendChild(line);
        // Auto-scroll to the bottom
        output.scrollTop = output.scrollHeight;
    }

    function startCommandStream(commandLine) {
        // Disable input/button while running
        input.disabled = true;
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Running...';

        // Clear previous output
        // output.innerHTML = ''; // Optional: clear on new command
        appendOutput(`Executing: labbuild ${commandLine}`);

        // Close existing connection if any
        if (eventSource) {
            eventSource.close();
        }

        // Create data for POST request
        const formData = new FormData();
        formData.append('command', `labbuild ${commandLine}`); // Prepend 'labbuild'

        // Use Fetch API to POST to the streaming endpoint
        fetch("{{ url_for('stream_command') }}", {
            method: 'POST',
            body: formData // Send command in the body
        })
        .then(response => {
             if (!response.ok) {
                // Handle HTTP errors before trying to stream
                throw new Error(`HTTP error ${response.status}`);
            }
             // Use response.body.getReader() for more control if needed,
             // but EventSource is simpler for SSE
             // For now, let's just connect EventSource after POST confirms start (less ideal)

             // Alternative: Connect EventSource directly (GET request, pass command via URL?)
             // Or use POST + response stream -> More complex JS needed.

             // Sticking with simpler POST -> EventSource approach for now,
             // acknowledging the command runs even if EventSource fails to connect immediately.
             // A better way would use WebSockets or handle the POST response body stream directly.

             // --- Connect to EventSource ---
             // NOTE: Passing command via query param for SSE GET request is simpler,
             // but less secure and has URL length limits. We use POST to *initiate*
             // and then rely on the server-side holding the command context (not ideal).
             // For simplicity here, we'll just trigger the POST and assume the server runs it.
             // A robust solution would use WebSockets.

             // Let's assume the POST was just to trigger the background process.
             // Now, we can *potentially* connect to a *separate* SSE endpoint
             // that streams logs based on the *latest* run_id, but that's complex.

             // --- Simplified SSE connection (less secure, uses GET) ---
             // This is NOT using the POST response body
             // const encodedCommand = encodeURIComponent(`labbuild ${commandLine}`);
             // eventSource = new EventSource(`/stream-command-get?command=${encodedCommand}`);

             // --- Sticking to POST trigger method ---
             // We won't get real-time output with this simple POST trigger.
             // We need to modify the approach if real-time stream is essential.
             // Let's just log completion for now.

             // For demo purposes, let's fake the SSE connection setup
             // Replace this fake setup with actual SSE/WebSocket connection logic

             console.log("Command submitted via POST. Real-time streaming requires WebSockets or handling response stream body.");
             appendOutput("Command submitted to server...", false);
             // Re-enable form after a short delay (since we don't have real stream confirmation)
             setTimeout(() => {
                 enableForm();
                 appendOutput("Process likely finished (check logs).", false);
             }, 5000); // Fake delay


        })
        .catch(error => {
            console.error('Fetch error:', error);
            appendOutput(`Error submitting command: ${error}`, true);
            enableForm(); // Re-enable form on fetch error
        });


        // --- Actual EventSource Logic (Example - if using GET endpoint) ---
        /*
        eventSource = new EventSource(`/stream-command-get?command=${encodedCommand}`); // Example GET endpoint

        eventSource.onmessage = function(event) {
            // Replace escaped newlines back
            const message = event.data.replace(/\\n/g, '\n');
            appendOutput(message);
        };

        eventSource.onerror = function(event) {
            console.error("EventSource failed:", event);
            appendOutput("Error: Connection to server lost.", true);
            enableForm();
            eventSource.close();
        };

        // Custom event for errors from the stream
        eventSource.addEventListener('error', function(event) {
             const message = event.data.replace(/\\n/g, '\n');
             appendOutput(`Server Error: ${message}`, true);
        });

         // Custom event to signal process completion
        eventSource.addEventListener('close', function(event) {
             const message = event.data.replace(/\\n/g, '\n');
             appendOutput(`--- ${message} ---`, false);
             enableForm();
             eventSource.close(); // Close the connection
        });
        */
    }

    function enableForm() {
        input.disabled = false;
        submitBtn.disabled = false;
        submitBtn.innerHTML = 'Execute';
    }

    form.addEventListener('submit', (e) => {
        e.preventDefault(); // Prevent actual form submission
        const commandLine = input.value.trim();
        if (commandLine) {
            // Basic client-side check (matches server-side)
            if (!commandLine.startsWith('setup') && !commandLine.startsWith('manage') && !commandLine.startsWith('teardown') && !commandLine.startsWith('-l')) {
                 appendOutput("Invalid command format. Must start with setup, manage, teardown, or -l.", true);
                 return;
            }
            // Clear previous output before starting new command
            output.innerHTML = '';
            startCommandStream(commandLine);
            // input.value = ''; // Optional: clear input after submit
        }
    });

    clearBtn.addEventListener('click', () => {
        output.innerHTML = ''; // Clear the output area
    });

</script>
{% endblock %}