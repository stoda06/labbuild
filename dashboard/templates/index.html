{% extends 'base.html' %}

{% block title %}LabBuild Dashboard{% endblock %}

{% block content %}
  <h1 class="mb-4">LabBuild Control</h1>

  <!-- Run/Schedule Form Card -->
  <div class="card">
    <div class="card-header">Run or Schedule Operation</div>
    <div class="card-body">
      {# --- Run Now Form --- #}
      <form id="runForm" action="{{ url_for('run_now') }}" method="POST" class="mb-4">
         <div class="row g-3">
            {% include '_form_fields.html' %} {# Include common form fields #}
         </div>
         <div class="mt-3">
             <button type="submit" class="btn btn-primary">Run Now</button>
         </div>
      </form>

      <hr class="my-4">

      {# --- Schedule Form --- #}
       <form id="scheduleForm" action="{{ url_for('schedule_run') }}" method="POST">
        <div class="row g-3">
            {% include '_form_fields.html' %} {# Include common form fields again #}
            <div class="col-md-4">
              <label for="schedule_type" class="form-label">Schedule Type</label>
              <select class="form-select" id="schedule_type" name="schedule_type">
                <option value="date" selected>Specific Date/Time</option>
                <option value="cron">Cron Expression</option>
                <option value="interval">Interval</option>
              </select>
            </div>
            {# --- Schedule Detail Inputs (controlled by JS) --- #}
            <div class="col-md-8" id="schedule_details_date">
                <label for="schedule_time" class="form-label">Run At (Local Time)</label>
                <input type="datetime-local" class="form-control" id="schedule_time" name="schedule_time">
                <div class="form-text">Browser time will be converted to UTC for scheduling.</div>
            </div>
            <div class="col-md-8" id="schedule_details_cron" style="display: none;">
                <label for="cron_expression" class="form-label">Cron Expression (min hour day month dow)</label>
                <input type="text" class="form-control" id="cron_expression" name="cron_expression" placeholder="e.g., 0 2 * * *">
                 <div class="form-text">Uses UTC timezone.</div>
            </div>
            <div class="col-md-8" id="schedule_details_interval" style="display: none;">
                <label for="interval_value" class="form-label">Interval</label>
                <div class="input-group">
                    <input type="number" class="form-control" id="interval_value" name="interval_value" placeholder="e.g., 60" min="1">
                    <select class="form-select" id="interval_unit" name="interval_unit" style="max-width: 120px;">
                        <option value="minutes" selected>Minutes</option>
                        <option value="hours">Hours</option>
                        <option value="days">Days</option>
                        <option value="weeks">Weeks</option>
                    </select>
                </div>
            </div>
         </div> {# End row #}
         <div class="mt-3">
             <button type="submit" class="btn btn-success">Schedule</button>
         </div>
       </form>
    </div> {# End card-body #}
  </div> {# End card #}


  <!-- Scheduled Jobs Card -->
  <div class="card">
    <div class="card-header">Scheduled Jobs</div>
    <div class="card-body">
      {% if jobs %}
        <div class="table-responsive"> {# Make table scrollable on small screens #}
            <table class="table table-sm table-striped table-hover">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Name</th>
                  <th>Next Run</th> {# Changed Header #}
                  <th>Trigger</th>
                  <th>Command Args</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for job in jobs %}
                <tr>
                  <td><small>{{ job.id }}</small></td>
                  <td>{{ job.name }}</td>
                  {# Use span for JS formatting #}
                  <td><span class="local-datetime" data-timestamp="{{ job.next_run_time_iso }}"></span></td>
                  <td><small>{{ job.trigger_info }}</small></td>
                  <td><small>{{ job.args }}</small></td>
                  <td>
                    <form action="{{ url_for('delete_job', job_id=job.id) }}" method="POST" style="display:inline;">
                      <button type="submit" class="btn btn-danger btn-sm" onclick="return confirm('Delete job {{ job.id }}?');">Delete</button>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
        </div>
      {% else %}
        <p>No jobs currently scheduled.</p>
      {% endif %}
    </div> {# End card-body #}
  </div> {# End card #}

  <div class="mb-3 text-end">
    <a href="{{ url_for('all_logs') }}" class="btn btn-outline-primary btn-sm">View All Logs Â»</a>
  </div>

  <!-- Recent Runs Card -->
  <div class="card mb-4">
    <div class="card-header">Recent Runs (Latest 5)</div>
    <div class="card-body">
      {% if recent_runs %}
       <div class="table-responsive">
            <table class="table table-sm table-striped table-hover">
              <thead>
                <tr>
                  <th>Run ID</th>
                  <th>Command</th>
                  <th>Start Time</th> {# Changed Header #}
                  <th>Duration</th>
                  <th>Status</th>
                  <th>Success</th>
                  <th>Failed</th>
                  <th>Details</th>
                </tr>
              </thead>
              <tbody id="recent-runs-tbody"> {# ID for JS selection #}
                {% for run in recent_runs %}
                <tr data-run-id="{{ run.run_id }}" data-status="{{ run.overall_status }}">
                  <td><small>{{ run.run_id }}</small></td>
                  <td>{{ run.command }}</td>
                  {# Use span for JS formatting #}
                  <td><span class="local-datetime" data-timestamp="{{ run.start_time_iso }}"></span></td>
                  <td id="duration-{{ run.run_id }}">{{ ('%.2f'|format(run.duration_seconds)) if run.duration_seconds is not none else '...' }}s</td>
                  <td id="status-{{ run.run_id }}" class="status-cell status-{{ run.overall_status|lower|replace(' ', '_') }}">
                      {{ run.overall_status }}
                      {% if run.overall_status == 'running' %}<span class="spinner-border spinner-border-sm text-primary ms-1" role="status" aria-hidden="true"></span>{% endif %}
                  </td>
                  <td id="success-{{ run.run_id }}">{{ run.summary.success_count if run.summary else '?' }}</td>
                  <td id="failure-{{ run.run_id }}">{{ run.summary.failure_count if run.summary else '?'}}</td>
                  <td><a href="{{ url_for('log_detail', run_id=run.run_id) }}" class="btn btn-secondary btn-sm">View Log</a></td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
        </div>
      {% else %}
        <p>No recent runs found.</p>
      {% endif %}
    </div> {# End card-body #}
  </div> {# End card #}

{% endblock %}

{# --- Page Specific Scripts --- #}
{% block scripts %}
{{ super() }} {# Include scripts from base.html (dark mode, base timezone JS) #}
<script>
    // --- Schedule Form Type Toggle ---
    const scheduleTypeSelect = document.getElementById('schedule_type');
    const dateDetails = document.getElementById('schedule_details_date');
    const cronDetails = document.getElementById('schedule_details_cron');
    const intervalDetails = document.getElementById('schedule_details_interval');

    // --- Course Autocomplete ---
    const vendorSelect = document.getElementById('vendor');
    const courseInput = document.getElementById('course');
    const courseSuggestions = document.getElementById('course-suggestions');
    let debounceTimer;

    async function fetchCourseSuggestions() {
        const query = courseInput.value;
        const selectedVendor = vendorSelect.value;

        // Don't fetch if query is too short (optional)
        if (query.length < 1) {
             courseSuggestions.innerHTML = ''; // Clear suggestions
             return;
        }

        // Construct URL with query parameters
        let apiUrl = `/api/courses?q=${encodeURIComponent(query)}`;
        if (selectedVendor) {
            apiUrl += `&vendor=${encodeURIComponent(selectedVendor)}`;
        }

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                console.error('Failed to fetch course suggestions:', response.statusText);
                return;
            }
            const suggestions = await response.json();

            // Update datalist options
            courseSuggestions.innerHTML = ''; // Clear previous options
            suggestions.forEach(suggestion => {
                const option = document.createElement('option');
                option.value = suggestion;
                courseSuggestions.appendChild(option);
            });
        } catch (error) {
            console.error('Error during course suggestion fetch:', error);
        }
    }

    // Debounce function to limit API calls while typing
    function debounce(func, delay) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(func, delay);
    }

    // Event listener for course input
    courseInput.addEventListener('input', () => {
        debounce(fetchCourseSuggestions, 300); // Fetch after 300ms pause in typing
    });

    // Event listener for vendor change (update suggestions immediately)
    vendorSelect.addEventListener('change', fetchCourseSuggestions);

    function updateScheduleDetailsVisibility() {
        const selectedType = scheduleTypeSelect.value;
        dateDetails.style.display = 'none'; // Hide all first
        cronDetails.style.display = 'none';
        intervalDetails.style.display = 'none';
        if (selectedType === 'date') dateDetails.style.display = 'block';
        else if (selectedType === 'cron') cronDetails.style.display = 'block';
        else if (selectedType === 'interval') intervalDetails.style.display = 'block';
    }
    scheduleTypeSelect.addEventListener('change', updateScheduleDetailsVisibility);
    updateScheduleDetailsVisibility(); // Initial call

    // --- Run Status Polling ---
    const pollingInterval = 5000; // Poll every 5 seconds
    const activePolls = new Map(); // Store active intervals { run_id: intervalId }

    function updateRunStatusRow(runId, data) {
        const row = document.querySelector(`tr[data-run-id="${runId}"]`);
        if (!row) return;

        const statusCell = document.getElementById(`status-${runId}`);
        const durationCell = document.getElementById(`duration-${runId}`);
        const successCell = document.getElementById(`success-${runId}`);
        const failureCell = document.getElementById(`failure-${runId}`);

        if (!statusCell || !durationCell || !successCell || !failureCell) return;

        // Update Status Cell
        let currentStatusText = statusCell.firstChild; // Get the main status text node/element
        let statusClass = `status-${data.overall_status.toLowerCase().replace(/ /g, '_')}`;
        let spinner = statusCell.querySelector('.spinner-border');
        let hintSpan = statusCell.querySelector('.last-pod-hint');

        // Update text if needed
        if (currentStatusText && currentStatusText.nodeType === Node.TEXT_NODE && currentStatusText.nodeValue.trim() !== data.overall_status) {
            currentStatusText.nodeValue = data.overall_status + ' ';
        } else if (!currentStatusText || currentStatusText.nodeType !== Node.TEXT_NODE) {
            statusCell.insertBefore(document.createTextNode(data.overall_status + ' '), statusCell.firstChild);
        }

        // Add/Remove Spinner
        if (data.overall_status === 'running') {
            if (!spinner) { // Add spinner only if it doesn't exist
                 spinner = document.createElement('span');
                 spinner.className = "spinner-border spinner-border-sm text-primary ms-1";
                 spinner.setAttribute('role', 'status');
                 spinner.setAttribute('aria-hidden', 'true');
                 statusCell.appendChild(spinner);
            }
            // Add/Update hint about the last pod status
             if (data.last_pod_status) {
                 let lastStatus = data.last_pod_status;
                 let lastMsg = `(Pod ${lastStatus.identifier || 'N/A'}: ${lastStatus.status || '...'}`;
                 if (lastStatus.status === 'failed') {
                     lastMsg += ` at ${lastStatus.step || 'step'}`;
                 }
                 lastMsg += ')';
                 if (!hintSpan) {
                     hintSpan = document.createElement('small');
                     hintSpan.className = 'text-muted d-block last-pod-hint';
                     statusCell.appendChild(hintSpan); // Append after spinner
                 }
                 hintSpan.textContent = lastMsg;
             } else if (hintSpan) {
                 hintSpan.remove(); // Remove hint if no last status
             }
        } else {
             if(spinner) spinner.remove(); // Remove spinner if not running
             if(hintSpan) hintSpan.remove(); // Remove hint if not running
        }

        // Update status cell class
        statusCell.className = `status-cell ${statusClass}`;

        // Update Counts
        successCell.textContent = data.success_count !== null ? data.success_count : '?';
        failureCell.textContent = data.failure_count !== null ? data.failure_count : '?';

        // Update Duration if finished
        if (data.duration_seconds !== null) {
            durationCell.textContent = data.duration_seconds.toFixed(2) + 's';
        } else if (row.dataset.status === 'running') { // Only show ellipsis if still running
             durationCell.textContent = '...';
        }


        // Update data-status attribute on the row
        row.dataset.status = data.overall_status;

        // Re-format any potential new timestamps in the updated row (like last_pod_status hint)
        // We need to specifically target the spans within this row if hints are added dynamically
        row.querySelectorAll('.local-datetime').forEach(span => {
             const isoTimestamp = span.dataset.timestamp;
             if (isoTimestamp && !span.classList.contains('js-formatted-time')) {
                 span.textContent = formatLocalDateTime(isoTimestamp);
                 span.classList.add('js-formatted-time');
             } else if (!isoTimestamp && !span.classList.contains('js-formatted-time')) {
                 span.textContent = 'N/A';
                 span.classList.add('js-formatted-time');
             }
        });
    }

    async function pollRunStatus(runId) {
        try {
            const response = await fetch(`/status/${runId}`);
            if (!response.ok) { console.error(`Error fetch status ${runId}: ${response.statusText}`); if (response.status === 404) stopPolling(runId); return; }
            const data = await response.json();
            updateRunStatusRow(runId, data);
            const finalStates = ['completed', 'completed_with_errors', 'failed', 'failed_exception', 'terminated_by_user', 'unknown'];
            if (finalStates.includes(data.overall_status)) { stopPolling(runId); }
        } catch (error) { console.error(`Polling failed ${runId}:`, error); }
     }

    function stopPolling(runId) {
        if (activePolls.has(runId)) {
            clearInterval(activePolls.get(runId)); activePolls.delete(runId);
            const row = document.querySelector(`tr[data-run-id="${runId}"]`);
            if(row){ const statusCell = document.getElementById(`status-${runId}`);
                if(statusCell){ const spinner = statusCell.querySelector('.spinner-border'); if(spinner) spinner.remove(); const hint = statusCell.querySelector('.last-pod-hint'); if(hint) hint.remove(); }
            }
        }
     }

    function startPollingForRunningJobs() {
        const tableBody = document.getElementById('recent-runs-tbody'); if (!tableBody) return;
        const runningRows = tableBody.querySelectorAll('tr[data-status="running"]');
        // console.log(`Found ${runningRows.length} running jobs to poll.`);
        runningRows.forEach(row => {
            const runId = row.dataset.runId;
            if (runId && !activePolls.has(runId)) {
                // console.log(`Starting polling for run_id: ${runId}`);
                pollRunStatus(runId); // Poll immediately
                const intervalId = setInterval(() => pollRunStatus(runId), pollingInterval);
                activePolls.set(runId, intervalId);
            }
        });
     }
    // Start polling when the page loads
    document.addEventListener('DOMContentLoaded', startPollingForRunningJobs);

</script>
{% endblock %}